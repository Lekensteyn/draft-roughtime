<?xml version="1.0" encoding="US-ASCII"?> <!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"> <!ENTITY
RFC5280 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml"> <!ENTITY
RFC5905 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.5905.xml"> <!ENTITY
RFC8174 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.8174.xml"> <!ENTITY
RFC7384 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.7384.xml">
<!ENTITY RFC0020 SYSTEM
"http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.0020.xml">
<!ENTITY RFC8032 SYSTEM
"http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8032.xml">
<!ENTITY NTS SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-ntp-using-nts-for-ntp.xml">
<!ENTITY NTP SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-ntp-mac.xml">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes"?>
<?rfc toc="no"?>
<?rfc tocdepth="3"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc category="info" docName="draft-roughtime-aanchal-00" ipr="trust200902">
  <front>
    <title>Roughtime</title>

    <author fullname="Aanchal Malhotra" initials="A." surname="Malhotra">
        <organization>Boston University</organization>
        <address>
            <postal>
                <street>111 Cummington Mall</street>
                <city>Boston</city>
                <region></region>
                <code>02215</code>
                <country>USA</country>
            </postal>
            <email>aanchal4@bu.edu</email>
        </address>
    </author>

    <author fullname="Adam Langley" initials="A." surname="Langley">
      <organization>Google </organization>
    </author>

    <author fullname="Watson Ladd" initials="W." surname="Ladd">
        <organization> Cloudflare</organization>
        <address>
            <postal>
                <street>101 Townsend St</street>
                <city>San Francisco</city>
                <region></region>
                <country>USA</country>
            </postal>
            <email>watson@cloudflare.com</email>
        </address>
    </author>

    <date year="2019" month="February" day="8"/>

    <area>General</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <keyword>roughtime</keyword>

    <keyword>time synchronization</keyword>

    <abstract>
      <t>
        This document specifies Roughtime - a protocol that aims to achieve rough time synchronization while detecting servers that provide inaccurate time and providing cryptographic proof of their malfeasance.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Motivation">
      <t>
        Time synchronization is essential to Internet security as many
        security protocols and other applications require synchronization <xref
        target="RFC7384"/><xref target="MCBG"/>. Unfortunately widely deployed protocols
        such as the Network Time Protocol (NTP) <xref target="RFC5905"/> lack essential security
        features, and even newer protocols like Network Time Security (NTS) <xref target="I-D.ietf-ntp-using-nts-for-ntp"/> fail to ensure that the servers
        behave correctly. Authenticating time servers prevents
        network adversaries from modifying time packets. An authenticated time server still has full control over the contents of time packet and may go rogue. Roughtime protocol provides cryptographic
        proof of malfeasance, enabling clients to detect and prove to a third party server's attempts to
        influence the time a client computes.
    </t>
       <texttable anchor = "existing_approaches">
        <ttcol align='center'>Protocol</ttcol>
        <ttcol align='center'>Authenticated Server</ttcol>
        <ttcol align='center'>Server Malfeasance Evidence</ttcol>
        <c>NTP, Chronos</c>     <c>N</c> <c>N</c>
        <c>NTP-MD5</c> <c>Y*</c><c>N</c>
        <c>NTP-Autokey</c><c>Y**</c><c>N</c>
        <c>NTS</c>      <c>Y</c><c>N</c>
        <c>Roughtime</c><c>Y</c><c>Y</c>
        <postamble>   Security Properties of current protocols </postamble>
      </texttable>
      <t>
      Y* For security issues with symmetric-key based NTP-MD5 authentication, please refer to <xref target="I-D.ietf-ntp-mac">Message Authentication Code for the Network Time Protocol draft</xref>
    </t>
    <t>
      Y** For security issues with Autokey Public Key Authentication, refer to <xref target="Autokey"/> 
    </t>
    </section>
    
<section title = "Requirements Language">
  <t>
    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
      "MAY", and "OPTIONAL" in this document are to be interpreted as
      described in BCP 14 <xref target="RFC2119"></xref> <xref target="RFC8174"></xref> when, and only when, they appear in all capitals, as shown here.
  </t>
</section>
<section title = "Protocol Overview">

  <t>
    Roughtime is a protocol for rough time synchronization that
    enables clients to provide cryptographic proof of server
    malfeasance. It does so by having responses from servers include
    a signature with a certificate rooted in long term
    public/private key pair over a portion of the initial request,
    thus providing cryptographic proof that the timestamp was issued
    after previous responses and before future ones.
  </t>
  <t>
    Single server mode: At its most basic level, Roughtime is a one
    round protocol in which a completely fresh client requests the
    current time and the server sends a signed response. The response
    includes a timestamp (the number of microseconds since the
    Unix epoch) and a radius (in microseconds) used to indicate the
    server's certainty about the reported time. For example, a radius
    of 1,000,000 microseconds means the server is absolutely confident
    that the true time is within one second of the reported time.
  </t>
  <t>
    The server proves freshness of its response as follows: The
    request contains a random challenge. The server incorporates the
    challenge into its signed response so that its needed to verify
    the signature. This proves that the signed response could only
    have been generated after the challenge was issued if the
    challenge has sufficient entropy.
  </t>
  <t>
    Chaining multiple servers: For subsequent requests, the client
    generates its nonce by hashing the reply from the first server
    with a random value. This proves that the nonce was created after
    the reply from the first server. It sends that to the second
    server and receives a signature from it covering that nonce and
    the time from the second server.
  </t>
  <t>
    Cryptographic proof of misbehavior: If the time from the
    second server is before the first, then the client has proof of
    misbehavior; the reply from the second server implicitly shows
    that it was created later because of the way that the client
    constructed the nonce. If the time from the second server is
    after, then the client can contact the first server again and get
    a signature that was provably created afterwards, but with an
    earlier timestamp.
  </t>
  <t>
    With only two servers, the client can end up with proof that
    something is wrong, but no idea what the correct time is. But with
    half a dozen or more independent servers, the client will end up
    with chain of proof of any server's misbehavior, signed by several
    others, and (presumably) enough accurate replies to establish what
    the correct time is. Furthermore this proof may be validated by
    third parties ultimately leading to a revocation of trust in the
    misbehaving server.
  </t>
</section>
<section title = "Message Format">
  <t>
    A Roughtime packet is a UDP packet whose contents are interpreted
    as a map from uint32s to strings of bytes. The byte strings must
    all have lengths a multiple of four. All uint32 are encoded with
    the least significant byte first. The keys of this map are called
    tags, and we speak of the value of a tag as the string of bytes it
    is mapped to.
  </t>
  <t>
  A Roughtime packet is serialized as follows: First there is a
  header, The first four bytes in the header are the uint32 number of
  tags N, and hence of (tag, value) pairs.  4*(N-1) bytes are offsets,
  each offset a uint32.  The last 4*N bytes are the tags.
  </t>
  <t>
  Tags are in ascending order, and no tag can be repeated. Offsets are
  all a multiple of four and MUST be strictly increasing. The offset
  array is considered to have a not explicitly encoded value of 0 as
  its zeroeth entry.
  </t>
  <t>
  Immediately following the header is a concatenation of all the
  strings. The first post-header byte is at offset 0, and the end of
  the final byte string is indicated by the end of the packet. The ith
  byte string ends at offset[i+1]-1, counting of course from 0, and
  begins at offset[i]. It is the value associated to the ith tag.
  </t>
  <t>
  This encoding may be recursive: a value may be said to be in
  Roughtime format and thus have a header, etc.  Tags may be
  listed as four ASCII characters <xref target="RFC0020"/>. In this
  case the tag when serialized will be those four ASCII
  characters. For example NONC would be the numeric value
  0x434e4f4e.  They may also be listed as fewer then four ASCII
  characters with hex escape codes at the end.
  </t>
</section>

<section title="Protocol">
  <section title="Queries">
    <t>
      A query is a Roughtime packet with the tag NONC. The contents of
      NONC are 64 bytes. The request packet MUST be a minimum of 1024
      bytes. To attain this size the tag PAD\xff MAY be added at the
      end of the packet with a conent of all zeros. Other tags MUST be
      ignored by the server. Future versions may specify additional
      tags and their semantics, so clients MUST NOT add other tags.
    </t>
  </section>
  <section title="Responses">
    <t>
      A response contains the following tags: SREP, SIG\x00, CERT, INDX, PATH,
      SREP value is itself in Roughtime format that  contains the folowing tags: ROOT, MIDP, RADI.     
      SIG\x00 is an Ed25519 signature <xref target="RFC8032"/> over the SREP value using the  public key contained in CERT as explained later.
    </t>
    <t>
    
    CERT in Roughtime format and contains the following tags: DELE, SIG\x00.
    This SIG\x00 is an Ed25519 signature over DELE using the long term public key of the server.
    DELE is itself in Roughtime format containing tags MINT, MAXT, PUBK.
    </t>
    <section title="SREP">
      <t>
        ROOT contains the root hash value of a Merkle tree using SHA512 as described when we reach the PATH and INDX blocks
        MIDP contains an uint64 value consisting of the number of microseconds since the Unix epoch in the smeared scale.
        RADI contains the server's estimate of the accuracy of MIDP. Servers MUST ensure the true time is within (MIDP-RADI, MIDP+RADI) at the time they compose the response packet.
      </t>
    </section>
    <section title="DELE">
      <t>
        MINT is the minimum uint64 timestamp at which the key in PUBK is trusted to begin signing time. MIDP &gt; MINT for validity.
        MAXT is the maximum uint64 timestamp at which PUBK may sign. MIDP &lt; MAXT for validity.
        PUBK is a temporary Ed25519 public key. The use of this field is to enable seperation of a root public key from keys on
        devices exposed to the public Internet.
      </t>
    </section>
    <section title="INDX and PATH">
      <t>
      INDX is a uint32 determining the position of NONC in a Merkle tree. PATH determines the values to be hashed with the running
      hash as one ascends the tree. The final value MUST be equal to ROOT.

      PATH is a multiple of 64 bytes long. One starts by computing the hash of the NONC value from the request, with \x00 preappended.
      Then one walks from the least significant bit of INDX to the most significant bit, and also walks towards the end of PATH.

      If PATH ends then the remaining bits of the INDX MUST be all zero. This indicates the termination of the walk.

      If the current bit is 0, one hashes \x01, the current hash, and the value from PATH.
      If the current bit is 1 one hashes \x01, the value from PATH, and the current HASH.
      This enables servers to batch signing when busy.
      </t>
    </section>
  </section>

  <section title ="Validity of response">
    <t>
    A client MUST check the following properties when it receives a response. We assume the long term server public key is known
    to the client through other means.

    <list>
      <t> The signature in CERT was made with the long-term key of the server</t>
      <t> The DELE timestamps and the MIDP value are consistent</t>
      <t> The INDX and PATH values prove NONC was included in the Merkle tree with value ROOT</t>
      <t> The signature of SREP in SIG\x00 validates with the public key in DELE</t>
    </list>

    A response that passes these checks is said to be valid. Validity of a response does not prove the time is correct, but merely
    that the server signed it, and more specifically began to compute the signature at a time in between (MIDP-RADI, MIDP+RADI).
    </t>
  </section>
</section>
<section title="The smeared scale">
  <t>
    Every day in Roughtime has 86400 seconds. A day without a leap second is a day where all seconds are SI seconds. A day with a positive leap second is one where every second is 86401/86400 SI seconds long. A day with a negative leap second is a day where every second is 86399/86400 SI seconds long. Days begin and end at noon, and when a leap-second is added or removed from UTC it is smeared out over the course of a day.
  </t>
  <t>
    Arithemtic on the smeared scale requires knowing when the seconds changed length and thus requires a leap second table.
  </t>
</section>

<section title="Cheater detection">
  <t> A chain of responses is a series of responses where the SHA-512 hash of the preceding response H, is concatenated with a 64 bit blind X, and then SHA-512(H, X)  is the NONC used in the subsequent response. These may be represented in JSON as TBD</t>

  <t>A pair of responses (r_1, r_2) is invalid if MIDP_1-RADI_1 &gt; MIDP_2+RADI_2. A chain of longer length is invalid if for any i, j such that i &lt; j, (r_i, r_j) is an invalid pair.</t>

  <t>Invalidity of a chain is proof that causality has been violated if all servers were reporting correct time. An invalid chain where all individual responses are valid is cryptographic proof of malfeasance of at least one server: if all servers had the
  correct time in the chain, causality would imply that MIDP_1-RADI_1 &lt; MIDP_2+RADI_2.
  </t>
</section>
<section title="Grease">
  <t> Servers MAY send back a fraction of responses that are syntactically invalid or contain invalid signatures as well as incorrect times. Clients MUST properly reject such responses.
  </t>
</section>
<section title="Roughtime Servers">
  <t>
    The below list contains a list of servers with their public keys in either
    Base64 or hexadecimal format.
  <list>
    <t> roughtime.int08h.com:2002; AW5uAoTSTDfG5NfY1bTh08GUnOqlRb+HVhbJ3ODJvsE=</t>
    <t> roughtime.cloudflare.com:2002; gD63hSj3ScS+wuOeGrubXlq35N1c5Lby/S+T7MNTjxo=</t>
    <t> roughtime.sandbox.google.com:2002; etPaaIxcBMY1oUeGpwvPMCJMwlRVNxv51KK/tktoJTQ=</t>
  </list>
  </t>
</section>


<section anchor="Acknowledgements" title="Acknowledgements">
  <t>
    TBD
  </t>
</section>

<section anchor="IANA" title="IANA Considerations">
  <t>This memo includes no request to IANA.</t>
</section>

<section title = "Security Considerations">
  <t>
    This protocol will not survive the advent of quantum
    computers. Currently only one signature scheme is
    supported. Maintaining a list of trusted servers and adjudicating
    violations of the rules by servers are not discussed in this
    document and are essential for security. Arithmetic on the
    adjusted timescale is interesting with intervals, and this may
    impact the interpretation of the MAXT and MINT fields. Servers
    carry out a significant amount of computation in response to
    clients, and thus may experience vulnerability to denial of
    service attacks.
  </t>
  <t>
    This protocol does not provide any confidentiality, and given the
    nature of timestamps such impact is minor. The compromise of a
    PUBK's private key, even past MAXT, is a problem as the private
    key can be used to sign invalid times that are in the range MINT
    to MAXT, and thus violate the good behavior guarantee of the
    server.
  </t>
  <t>
    Packets sent by the client MUST be at least 1024 bytes in length in order to
    mitigate amplification attacks, and servers MUST ignore request packets that
    are smaller than this length.
  </t>
</section>
<section title = "Privacy Considerations">
  <t>
    This protocol is designed to obscure all client
    identifiers. Servers necessarily have persistent long term
    identities essential to enforcing correct behavior.
  </t>
</section>
</middle>

<back>
  <references title="Informative References">
    &RFC5280;
    &RFC5905;
    &RFC7384;
    &RFC8174;
    &RFC2119;
    &RFC0020;
    &RFC8032;
    &NTS;
    &NTP;
    
    <reference anchor="MCBG" target="https://eprint.iacr.org/2015/1020">
      <front>
        <title>Attacking the Network Time Protocol</title>
        
        <author initials="A." surname="Malhotra" fullname="A. Malhotra">
          <organization/>
        </author>
        <author initials="I." surname="Cohen" fullname="I. Cohen">
          <organization/>
        </author>
        <author initials="E." surname="Brakke" fullname="E. Brakke">
          <organization/>
        </author>
        <author initials="S." surname="Goldberg" fullname="S. Goldberg">
          <organization/>
        </author>
        
        <date year="2015"/>
      </front>
    </reference>
    <reference anchor="Autokey" target="https://zero-entropy.de/autokey_analysis.pdf">
      <front>
        <title>Analysis of the NTP Autokey Procedures</title>
        
        <author initials="S." surname="Rottger">
          <organization/>
        </author>
        
        <date year="2012"/>
      </front>
    </reference>

  </references>
</back>
</rfc>
